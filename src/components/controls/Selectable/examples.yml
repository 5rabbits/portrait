-
  description: |
    Fixed height options allows for scroll virtualization.
  collapsible: true
  expanded: false
  inline: false
  code: >
    class Example extends React.PureComponent {
      state = {
        fixedHeight: true,
      }

      componentWillMount() {
        this.options = []

        for (let i = 1; i <= 10000; i++) {
          this.options.push({
            label: `Option ${i}`,
            value: i,
          })
        }
      }

      render() {
        return (
          <div>
            <div style={{ marginBottom: 32 }}>
              <div>
                <button
                  onClick={() => this.setState({ fixedHeight: !this.state.fixedHeight })}
                  type="button"
                  >
                  {this.state.fixedHeight && 'Use variable height'}
                  {!this.state.fixedHeight && 'Use fixed height'}
                </button>
              </div>
            </div>

            <Selectable
              optionHeight={this.state.fixedHeight ? 40 : null}
              options={this.options}
              renderer={
                ({
                  focusableRef,
                  focusedElement,
                  focused,
                  getSearchMatches,
                  getOptionProps,
                  getOverflowProps,
                  options,
                  scrollToFocusedElement,
                  search,
                  selectedOption,
                  setFocused,
                  setFocusedElement,
                  setSearch,
                  setValue,
                  value,
                }) =>
                  <div
                    className={classNames('selectable-dropdown', {
                      'selectable-dropdown--with-value': value != null,
                      'selectable-dropdown--without-value': value == null,
                    })}
                    >
                    <button
                      className="selectable-dropdown__control"
                      onClick={() => {
                        if (focused) {
                          setFocused(false)
                        }
                        else {
                          setFocused(true)

                          // Execute after the next paint
                          window.requestAnimationFrame(() =>Â {
                            setFocusedElement('input', { virtual: false })

                            const selectedIndex = options.indexOf(selectedOption)

                            if (selectedIndex !== -1) {
                              setFocusedElement(selectedIndex)
                              scrollToFocusedElement()
                            }
                          })
                        }
                      }}
                      type="button"
                      >
                      {selectedOption ? selectedOption.label : 'Select an option'}
                    </button>
                    {focused &&
                      <div className="selectable-dropdown__menu">
                        <div className="selectable-dropdown__searchWrapper">
                          <input
                            className="selectable-dropdown__searchInput"
                            onChange={event => setSearch(event.target.value)}
                            onKeyDown={event => {
                              switch (event.key) {
                                case 'ArrowDown':
                                  event.preventDefault()

                                  if (focusedElement === 'clear' || focusedElement === 'input') {
                                    setFocusedElement(0)
                                    scrollToFocusedElement()
                                  }
                                  else if (focusedElement === options.length - 1) {
                                    setFocusedElement('clear')
                                  }
                                  else {
                                    setFocusedElement(focusedElement + 1)
                                    scrollToFocusedElement()
                                  }
                                  break

                                case 'ArrowUp':
                                  event.preventDefault()

                                  if (focusedElement === 'input' || focusedElement === 0) {
                                    setFocusedElement('clear')
                                  }
                                  else if (focusedElement === 'clear') {
                                    setFocusedElement(options.length - 1)
                                    scrollToFocusedElement()
                                  }
                                  else {
                                    setFocusedElement(focusedElement - 1)
                                    scrollToFocusedElement()
                                  }
                                  break

                                case 'Enter':
                                  event.preventDefault()

                                  if (focusedElement === 'input') {
                                    return
                                  }

                                  if (focusedElement === 'clear') {
                                    setValue(null)
                                  }
                                  else {
                                    setValue(options[focusedElement].value)
                                  }

                                  setSearch('')
                                  setFocused(false)
                                  break
                              }
                            }}
                            placeholder="Write to search"
                            ref={focusableRef('input')}
                            type="text"
                            value={search}
                          />
                          {search &&
                            <button
                              className="selectable-dropdown__searchIcon"
                              onClick={() => {
                                setSearch('')
                                setFocusedElement('input', { virtual: false })
                              }}
                              type="button"
                              >
                              &times;
                            </button>
                          }
                        </div>

                        <div
                          className="selectable-dropdown__overflow"
                          {...getOverflowProps()}
                          >
                          {options.map((option, index) =>
                            <button
                              {...getOptionProps(option, {
                                className: classNames('selectable-dropdown__option', {
                                  'selectable-dropdown__option--selected': value === option.value,
                                  'selectable-dropdown__option--focused': index === focusedElement,
                                }),
                                onClick: () => {
                                  setFocused(false)
                                },
                                type: 'button',
                              })}
                              >
                              <div>
                                {getSearchMatches(option.label).map(term =>
                                  term.match ? <b key={term.fromIndex}>{term.text}</b> : term.text
                                )}
                              </div>
                            </button>
                          )}
                        </div>
                        <button
                          className={classNames('selectable-dropdown__bottomOption', {
                            'selectable-dropdown__option--focused': focusedElement === 'clear',
                          })}
                          onClick={() => {
                            setValue(null)
                            setFocused(false)
                          }}
                          onMouseEnter={() => setFocusedElement('clear')}
                          ref={focusableRef('clear')}
                          type="button"
                          >
                          Leave without value
                        </button>
                      </div>
                    }
                  </div>
              }
            />
          </div>
        )
      }
    }

    ReactDOM.render(<Example />, mountNode)
